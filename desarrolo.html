<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Proyecto Intermodular</title>
    <link rel="stylesheet" href="desarrollo.css">
</head>
<body>
    <a class="back" href="index.html">‚Üê Volver</a>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conceptos de Software e Ingenier√≠a del Software</title>
</head>
<body>

<h1>Conceptos de Software e Ingenier√≠a del Software</h1>

<h2>1. ¬øQu√© es el Software?</h2>
<p>
El software es la parte intangible del ordenador, es decir, todo aquello que no puedes tocar f√≠sicamente, pero que hace que el ordenador (hardware) funcione y realice tareas √∫tiles.
En palabras m√°s concretas:
Definici√≥n sencilla (estilo RAE):
El software es el conjunto de programas, instrucciones y datos que le indican al ordenador qu√© tareas debe realizar.
Definici√≥n m√°s completa (estilo Pressman, que aparece en tu presentaci√≥n):
El software no solo son los programas ejecutables, sino que incluye tres elementos:

Instrucciones (los propios programas o aplicaciones).
Estructuras de datos (la forma en que se organiza la informaci√≥n que usa el programa).
Documentaci√≥n (manuales, gu√≠as, comentarios del c√≥digo, etc.) que explica c√≥mo funciona y c√≥mo usarlo.
</p>
<div class="img">
        <img src="img/Foto 1 software.jpg" >
</div>
<h2>2. Tipos de software</h2>
<p>
	Software de sistemas: Windows, macOS, Linux‚Ä¶ Infraestructura con √©l.
	Software de programaci√≥n: herramientas que usan los programadores (editores, compiladores‚Ä¶).
	Software de aplicaci√≥n: programas cotidianos (navegadores, procesadores de texto, videojuegos‚Ä¶).
</p>
<h2>3. ¬øComo funciona el ordenador?</h2>
<p>
    El ordenador tiene tres partes principales:
1.	Unidad Central de Proceso (CPU)
	Ejecuta las instrucciones de los programas, traduciendo operaciones complejas en operaciones aritm√©ticas y l√≥gicas b√°sicas.
	Unidad Aritm√©tico-L√≥gica (ALU): ejecuta operaciones aritm√©ticas y l√≥gicas.
	Unidad de Control (UC): recoge y ordena la ejecuci√≥n de instrucciones.
	Registros: almacenamiento interno de la CPU.
2.	Memoria Principal (RAM)
	Contiene las instrucciones del programa y los datos.
	Es una memoria vol√°til que se borra al apagar el ordenador.
3.	Unidad de Entrada/Salida
	Perif√©ricos de Entrada: teclado, rat√≥n.
	Perif√©ricos de Salida: pantalla, impresora.
	Perif√©ricos de Entrada/Salida: m√≥dem, tarjeta de red, dispositivos de almacenamiento.

</p>
<h2>4. M√°quinas Virtuales: Concepto y Efectividad</h2>
<p>
    ¬øEn qu√© consiste la m√°quina virtual? Una m√°quina virtual (VM) es un software que simula un sistema de computaci√≥n integral, permitiendo el funcionamiento de un sistema operativo y programas como si estuvieran integrados en una computadora f√≠sica independiente. Es b√°sicamente un ordenador que se inserta en otro.
</p>
<h3 class="subtitulo">4.1. M√°quinas Virtuales de Sistema</h3>
 <p>Las aplicaciones de virtualizaci√≥n emulan un ordenador, permitiendo instalar sistemas operativos con componentes propios. La experiencia es similar a la de una m√°quina real. Ejemplos como VMware Workstation y VirtualBox son √∫tiles para tener varios sistemas en el mismo equipo. Su desventaja es el alto consumo de recursos del ordenador f√≠sico, especialmente memoria RAM y espacio en disco.
</p>  
<h3 class="subtitulo">4.2. M√°quinas Virtuales de Proceso</h3>
<p>
    Una m√°quina virtual ejecuta un proceso espec√≠fico dentro de un sistema operativo, activ√°ndose al inicio del proceso y deteni√©ndose al finalizar. Proporciona un entorno de ejecuci√≥n independiente del hardware y del sistema operativo, permitiendo que los programas se ejecuten uniformemente en distintas plataformas. Un ejemplo notable es la M√°quina Virtual de Java (JVM).
</p>
<h3 class="subtitulo">Proceso para Ejecutar un Programa en Java</h3>

<p>
 1.	Creaci√≥n del c√≥digo fuente: El desarrollador escribe el programa en lenguaje Java utilizando un editor de texto (.java).
 2.	Compilaci√≥n: El c√≥digo fuente se compila utilizando el compilador javac, produciendo un archivo con extensi√≥n .class si no se detectan errores. Este archivo contiene un lenguaje intermedio llamado bytecode, el cual es independiente de la plataforma.
 3.	Ejecuci√≥n: La M√°quina Virtual de Java traduce el archivo .class a c√≥digo binario para su ejecuci√≥n. Como la JVM est√° disponible en m√∫ltiples sistemas operativos (Windows, Linux, macOS, etc.), los programas pueden ejecutarse en diversas plataformas sin modificaciones.
</p>
<h2>5. Lenguajes de Programaci√≥n</h2>
<p>
    Un lenguaje de programaci√≥n es un conjunto estructurado de s√≠mbolos, palabras y reglas gramaticales que permite a los programadores escribir instrucciones espec√≠ficas para que una computadora ejecute tareas. Es una herramienta que act√∫a como puente entre el ser humano y la m√°quina, permitiendo expresar procesos l√≥gicos de manera comprensible tanto para el programador como para el sistema inform√°tico.
</p>
<div class="img">
        <img src="img/lenguaje progra.jpg" >
</div>
<h2>6. Conceptos de C√≥digo</h2>
<p>
C√≥digo Fuente: El c√≥digo fuente es el conjunto de instrucciones que los programadores escriben en un lenguaje de programaci√≥n para hacer que un programa o aplicaci√≥n funcione. Es como el ‚Äúgui√≥n‚Äù que le dice a la computadora qu√© hacer. Este c√≥digo se puede modificar y mejorar.
C√≥digo Objeto: Es el resultado de convertir el c√≥digo fuente a un formato que la computadora puede entender, pero a√∫n no es completamente ejecutable. Es un archivo intermedio que contiene instrucciones en lenguaje de bajo nivel, generalmente en c√≥digo binario, pero necesita pasar por un proceso de enlace (linking).
C√≥digo Ejecutable: Es el archivo final que la computadora puede ejecutar directamente. Es el resultado de enlazar todos los archivos de c√≥digo objeto.

</p>
<h2>7. Proceso de Obtenci√≥n de C√≥digo Ejecutable a partir de C√≥digo Fuente</h2>
<p>
    1.	Escritura del C√≥digo Fuente: El programador escribe el c√≥digo utilizando un editor de texto o un IDE.
2.	Compilaci√≥n: El compilador convierte el c√≥digo fuente en c√≥digo objeto, verificando errores de sintaxis.
3.	Enlazado (Linking): El enlazador combina el c√≥digo objeto con las bibliotecas necesarias para generar el archivo ejecutable final.
4.	Generaci√≥n del Archivo Ejecutable: Resultado ‚Üí .exe, .out, etc.
5.	Depuraci√≥n y Optimizaci√≥n: Uso de depuradores (ej. GDB) y optimizadores.
El caso de Java Java combina compilaci√≥n e interpretaci√≥n:
‚Ä¢	Primero el c√≥digo fuente se compila a bytecode (intermedio).
‚Ä¢	Luego, este bytecode es interpretado (o compilado JIT) por la m√°quina virtual de Java (JVM).
Herramientas Editores, compiladores/int√©rpretes, enlazadores ‚Üí normalmente integrados en IDEs (Eclipse, Visual Studio, IntelliJ‚Ä¶).
</p>
<h2>8. Tipos de Traductores</h2>
<p>
    1.	Compiladores
	Traducen todo el c√≥digo fuente de una vez.
	Detectan errores de sintaxis.
	Generan c√≥digo objeto (puede necesitar ensamblado y enlazado).
	El ejecutable resultante se ejecuta sin volver a compilar.
2.	Int√©rpretes
	Traducen y ejecutan l√≠nea por l√≠nea.
	M√°s lentos, pero permiten ejecuci√≥n inmediata y mayor portabilidad.
</p>
<h2>9. Clasificaci√≥n de los lenguajes de programaci√≥n</h2>
<p>
    Seg√∫n cercan√≠a al lenguaje m√°quina:
‚Ä¢	Lenguajes de bajo nivel (lenguaje m√°quina): binario, muy dif√≠ciles.
‚Ä¢	Lenguajes intermedios (ensambladores): c√≥digos simb√≥licos, 1 instrucci√≥n ensamblador = 1 instrucci√≥n m√°quina.
‚Ä¢	Lenguajes de alto nivel: Java, C++, Python, JavaScript‚Ä¶ M√°s f√°ciles y productivos.
Ventajas de los lenguajes de alto nivel
‚Ä¢	M√°s f√°ciles de aprender y usar.
‚Ä¢	Permiten crear programas m√°s complejos.
‚Ä¢	Mayor productividad.
Desventajas
‚Ä¢	Necesitan traducci√≥n.
‚Ä¢	Mayor consumo de recursos.
‚Ä¢	Menor eficiencia que bajo nivel.
Caracter√≠sticas principales de los lenguajes
‚Ä¢	Precisos
‚Ä¢	Tienen sintaxis (reglas gramaticales)
‚Ä¢	Muy diversos
Elementos b√°sicos de un lenguaje de programaci√≥n
‚Ä¢	Identificadores
‚Ä¢	Constantes
‚Ä¢	Operadores
‚Ä¢	Instrucciones
‚Ä¢	Comentarios
Paradigmas de programaci√≥n
‚Ä¢	Programaci√≥n estructurada
‚Ä¢	Programaci√≥n orientada a objetos (POO) ‚Üê dominante hoy
</p>
<h2>10. Raz√≥n de ser de la Ingenier√≠a del Software</h2>
<p>
    Surgi√≥ como respuesta a la creciente complejidad y a la ‚Äúcrisis del software‚Äù. Objetivos b√°sicos
1.	Mejora la calidad del software
2.	Mejorar el proceso de desarrollo
3.	Gesti√≥n de la complejidad
4.	Incrementar la mantenibilidad
5.	Fomentar la reutilizaci√≥n
</p>
<h2>11. Fases del desarrollo de una aplicaci√≥n inform√°tica</h2>
<p>
    El desarrollo de una aplicaci√≥n inform√°tica sigue un conjunto de etapas organizadas para asegurar que el producto final funcione correctamente y cumpla con las necesidades del usuario. Estas fases forman parte del ciclo de vida del software.
</p>
<h2>12. Modelo en Cascada (Waterfall)  el m√°s antiguo</h2>
<p>
    Es uno de los primeros modelos de desarrollo de software. Se llama en cascada porque las fases se ejecutan de forma secuencial, una despu√©s de otra, como si fueran ‚Äúcayendo‚Äù en cascada
</p>

<div class="img">
    <img src="img/11. Fases del desarrollo de una aplicaci√≥n inform√°tica.jpg">
    </div>
<h3 class="subtitulo">Caracter√≠sticas principales</h3>
<p>
Secuencial y lineal: No se avanza a la siguiente fase hasta terminar la anterior.
Documentaci√≥n completa: Cada fase debe ser documentada para continuar.
Poca retroalimentaci√≥n: No se regresa f√°cilmente a fases previas.
Ideal para proyectos bien definidos desde el inicio.
</p>
<h3 class="subtitulo">Fases del Modelo en Cascada</h3>
<div class="waterfall-container">

  <div class="fase">
    <h3>üîé 1. Requisitos</h3>
    <p>Se identifican todas las necesidades del cliente antes de comenzar. Se redacta un documento detallado: funciones, restricciones, objetivos.</p>
  </div>

  <div class="fase">
    <h3>üìê 2. Dise√±o</h3>
    <p>Se define la arquitectura del sistema. Se elabora el dise√±o de bases de datos, m√≥dulos, interfaces, y flujo de la aplicaci√≥n. Incluye diagramas y especificaciones t√©cnicas.</p>
  </div>

  <div class="fase">
    <h3>üíª 3. Implementaci√≥n (Desarrollo)</h3>
    <p>Los programadores escriben el c√≥digo fuente. Cada m√≥dulo se programa siguiendo el dise√±o previo. Todo se integra al final.</p>
  </div>

  <div class="fase">
    <h3>üß™ 4. Verificaci√≥n (Pruebas)</h3>
    <p>Se revisa que el software funcione correctamente. Se detectan errores, inconsistencias o fallos. Se realizan pruebas funcionales, pruebas de integraci√≥n y pruebas de sistema.</p>
  </div>

  <div class="fase">
    <h3>üîß 5. Mantenimiento</h3>
    <p>Se corrigen errores encontrados despu√©s de la entrega. Se hacen ajustes o mejoras. Incluye actualizaciones para mantener la aplicaci√≥n funcionando.</p>
  </div>

</div>
<h3 class="subtitulo">Ventajas del Modelo en Cascada</h3>
<p>
Simple y f√°cil de entender.
Buena organizaci√≥n: Cada fase tiene un inicio y un fin claramente definidos.
Ideal para proyectos peque√±os o con requisitos muy claros.
Mucha documentaci√≥n, √∫til para equipos nuevos o grandes.
</p>
<h3 class="subtitulo">Desventajas del Modelo en Cascada</h3>
<p>
Poca flexibilidad: No permite cambios f√°cilmente una vez que se pasa una fase.
Riesgo alto: Si un requisito se entendi√≥ mal al inicio, se arrastra el error hasta el final.
Cliente poco involucrado: La mayor parte del tiempo solo ve el producto al final.
Largo tiempo de espera: Las pruebas se realizan al final del desarrollo.
</p>
<h2>13. Otros modelos de ciclo de vida</h2>
<h3 class="subtitulo">Modelo Incremental</h3>
<p>
Idea principal: Se desarrolla el software en partes o incrementos, cada uno con funcionalidades completas.

C√≥mo funciona:
Se construye un n√∫cleo b√°sico del sistema.
Se agregan incrementos que ampl√≠an las funcionalidades.
Cada incremento se prueba y se entrega al usuario.

Ventajas:
Permite entregar funcionalidades antes de terminar todo el proyecto.
Facilita cambios y ajustes en incrementos posteriores.

Desventajas:
Puede requerir m√°s planificaci√≥n y gesti√≥n de integraci√≥n.
La arquitectura inicial debe estar bien dise√±ada para soportar los incrementos.
</p>
<h3 class="subtitulo">Modelo en Espiral</h3>
<p>
Idea principal: Combina desarrollo iterativo con un enfoque en la gesti√≥n de riesgos.

C√≥mo funciona:
El desarrollo se realiza en ciclos (espirales).
Cada ciclo pasa por cuatro fases: planificaci√≥n, an√°lisis de riesgos, desarrollo y evaluaci√≥n del cliente.

Ventajas:
Ideal para proyectos grandes y complejos.
Permite identificar y mitigar riesgos desde el inicio.
Facilita cambios en cualquier etapa.

Desventajas:
M√°s complejo y costoso que modelos lineales.
Requiere personal capacitado en gesti√≥n de riesgos.
</p>
<h3 class="subtitulo">Proceso Unificado de Rational (RUP)</h3>
<p>
Idea principal: Modelo iterativo con cuatro fases principales que cubren todo el ciclo de vida del software.

Fases del RUP:
Inicio (Inception): Definir objetivos y viabilidad del proyecto.
Elaboraci√≥n (Elaboration): Analizar riesgos, requisitos y arquitectura.
Construcci√≥n (Construction): Programar, integrar y probar el software.
Transici√≥n (Transition): Entregar el software al usuario y entrenar al personal.

Ventajas:
Flexible y adaptable a cambios.
Permite iteraciones para mejorar el producto continuamente.
Buen manejo de riesgos y calidad.

Desventajas:
Puede ser costoso y complejo de implementar.
Requiere experiencia en metodolog√≠as iterativas.
</p>
<h2>14. Metodolog√≠as √°giles (principios)</h2>
<p>
    ‚Ä¢	Individuos e interacciones > procesos y herramientas
‚Ä¢	Software funcionando > documentaci√≥n exhaustiva
‚Ä¢	Colaboraci√≥n con el cliente > negociaci√≥n contractual
‚Ä¢	Respuesta al cambio > seguir un plan r√≠gido
Programaci√≥n Extrema (XP) ‚Äì Kent Beck
‚Ä¢	Simplicidad, comunicaci√≥n, retroalimentaci√≥n, valent√≠a, respeto
‚Ä¢	Pruebas continuas, programaci√≥n en pareja, refactorizaci√≥n‚Ä¶
Scrum ‚Äì Jeff Sutherland
‚Ä¢	Sprints (ciclos cortos)
‚Ä¢	Pilares: Transparencia, Inspecci√≥n, Adaptaci√≥n
‚Ä¢	Reuniones: planificaci√≥n, daily, review, retrospectiva
</p>
<h2>15. Roles / Perfiles en un proyecto de software</h2>
<P>
‚Ä¢	Jefe de proyecto: planificaci√≥n, seguimiento, control y cierre. M√°ximo responsable.
‚Ä¢	Expertos del dominio: conocen la realidad del negocio/problema.
‚Ä¢	Analista: comunica con expertos del dominio y define requisitos funcionales.
‚Ä¢	Arquitecto: define la arquitectura global del sistema (c√≥mo se divide en componentes).
‚Ä¢	Dise√±ador (o analista t√©cnico/org√°nico): dise√±a en detalle los componentes.
‚Ä¢	Programador: escribe el c√≥digo fuente.
‚Ä¢	Probador (tester): ejecuta pruebas unitarias, integraci√≥n, sistema‚Ä¶ Garantiza calidad.
‚Ä¢	Encargado de la implantaci√≥n: empaquetado, instalaci√≥n, gesti√≥n de configuraci√≥n y versiones.
</P>
<h2>16. Fases detalladas del ciclo de vida (modelo cl√°sico)</h2>
<p>
‚Ä¢	An√°lisis: determinar QU√â debe hacer el sistema.
‚Ä¢	Dise√±o: decidir C√ìMO se va a hacer (componentes, bases de datos, etc.).
‚Ä¢	Implementaci√≥n / Programaci√≥n
‚Ä¢	Pruebas:
    o	Unitarias (m√≥dulos aislados)
    o	Integraci√≥n
    o	Sistema completo
    o	Validaci√≥n con requisitos del cliente
‚Ä¢	Explotaci√≥n: instalaci√≥n y puesta en marcha en el cliente.
‚Ä¢	Mantenimiento: correcci√≥n, adaptaci√≥n, perfeccionamiento y prevenci√≥n tras la entrega.
</p>
</body>
</html>
